# -*- coding: utf-8 -*-
"""Chatterbot.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UBCxQyo1YxqpoAJeL5kCmq_xdM87j6fF

"""

import secrets_t
import secrets_r

import sys

import os
import math
import json
from datetime import datetime

from dateutil.parser import parse

import tweepy
import requests
from requests_oauthlib import OAuth1


class Tweet:
  def __init__(self, record={}, json_record=None):
    if json_record is None:
      self.created_at = str(record.created_at)
      self.id = record.id_str
      self.text = record.text
      try:
        self.url = record.entities['urls'][0]['url']
      except IndexError:
        self.url = None
      self.user = dict()
      self.user['user_id'] = record.user.id_str
      self.user['name'] = record.user.name
      self.coordinates = record.coordinates
      # self.reply_count = record['reply_count']
      self.retweet_count = record.retweet_count
      self.favorite_count = record.favorite_count
      self.hashtags = record.entities['hashtags']
      self.type = "Tweet"
    else:
      self.created_at = json_record['created_at']
      self.id = json_record['id']
      self.text = json_record['text']
      try:
        self.url = json_record['url']
      except IndexError:
        self.url = None
      self.user = dict()
      self.user['user_id'] = json_record['user']['user_id']
      self.user['name'] = json_record['user']['name']
      self.coordinates = json_record['coordinates']
      # self.reply_count = json_record['reply_count']
      self.retweet_count = json_record['retweet_count']
      self.favorite_count = json_record['favorite_count']
      self.hashtags = json_record['hashtags']
      self.type = "Tweet"

class Post:
  def __init__(self, record={}, json_record=None):
    if json_record is None:
      self.id = record['data']['id']
      self.created_utc = record['data']['created_utc']
      self.title = record['data']['title']
      self.url = record['data']['url']
      self.selftext = record['data']['selftext']
      self.ups = record['data']['ups']
      self.downs = record['data']['downs']
      self.upvote_ratio = record['data']['upvote_ratio']
      self.num_comments = record['data']['num_comments']
      self.score = record['data']['score']
      self.subreddit = record['data']['subreddit']
      self.type = "Post"
    else:
      self.id = json_record['id']
      self.created_utc = json_record['created_utc']
      self.title = json_record['title']
      self.url = json_record['url']
      self.selftext = json_record['selftext']
      self.ups = json_record['ups']
      self.downs = json_record['downs']
      self.upvote_ratio = json_record['upvote_ratio']
      self.num_comments = json_record['num_comments']
      self.score = json_record['score']
      self.subreddit = json_record['subreddit']
      self.type = "Post"

def create_cache(object_list, json_cache_path):
  """Caches all attributes of the Tweet and Post objects in json format

  Args:
      object_list (List[Tweet/Post]): 
        List of Tweet/Post objects to cache
      cache_file_path (str): 
        Path to json cache file
  """
  json_data = {}
  json_data['cache_creation_time'] = str(datetime.now())
  json_data['data'] = dict()
  for object in object_list:
    json_data['data'][object.id] = object.__dict__
  with open(json_cache_path, "w") as cfile:
    json.dump(json_data, cfile)

def load_from_cache(json_cache_path):
  """Loads the objects of Tweet/Post into a json object.

  Args:
      cache_file_path (str): 
        Path to json cache file

  Returns:
      _type_: Dict{Dict{...}}
  """
  if os.path.exists(json_cache_path) and os.path.getsize(json_cache_path) != 0:
    with open(json_cache_path, "r") as cfile:
      json_data = json.load(cfile)
  else:
    print("Please provide a valid json cache")
    return None
  return json_data

def cache_age(cache_time):
  """Return time in hours that has passed since cache creation

  Args: 
      cache_time (str):
        Time in utc of cache creation
  
  Returns:
      _type_: int 
  """
  time_diff = datetime.now() - parse(cache_time)
  return time_diff.total_seconds() / (60*60)

def load_tweets(auth_t, json_cache_path):
  cached_json = load_from_cache(json_cache_path)
  if cached_json is None or cache_age(cached_json['cache_creation_time']) > 1:
    api = tweepy.API(auth_t, wait_on_rate_limit=True)
    response_twitter = api.search_tweets(q="all", lang="en", count=100)
    Tweet_list = [Tweet(record=record) for record in response_twitter]
    create_cache(Tweet_list, json_cache_path)
    return Tweet_list
  else:
    Tweet_list = [Tweet(json_record=cached_json['data'][r_id]) for r_id in cached_json['data'].keys()]
    return Tweet_list

def load_posts(headers, json_cache_path):
  cached_json = load_from_cache(json_cache_path)
  if cached_json is None or cache_age(cached_json['cache_creation_time']) > 1:
    params = {'q': 'all', 'limit' : 100}
    response_reddit = requests.get("https://oauth.reddit.com/search?", params=params, headers=headers) 
    Post_list = [Post(record=record) for record in response_reddit.json()['data']['children']]
    create_cache(Post_list, json_cache_path)
    return Post_list
  else:
    Post_list = [Post(json_record=cached_json['data'][r_id]) for r_id in cached_json['data'].keys()]
    return Post_list

def hotness(time, score):
  """ Takes time in utc and score as arguments
      (i.e. (upvotes - downvotes) for reddit and favorite_count for twitter)
      and calculates the hotness value of a post
  Args:
      time: int
      score: int
  Returns:
      __type__: int
  """
  if score <= 0:
    return time
  else:
    return math.log10(time) + math.log10(score)

"""Tree Structure"""

class TreeNode:
  def __init__(self, object):
    # General Notes
    # score = upvotes - downvotes
    # talked_abt_score = comments for reddit/ retweets for twitter
    if object.type == "Tweet":
      time = parse(object.created_at).timestamp()
      self.nodeVal = tuple((time, object.favorite_count, object.retweet_count, hotness(time, object.favorite_count)))
    else:
      time = object.created_utc
      self.nodeVal = tuple((time, object.ups, object.num_comments, hotness(time, object.ups)))
    self.object_ref = object
    self.left = None
    self.right = None

"""Tree helper functions"""

def insertNodeInTree(root, newNode, depth):
  if root is None:
    # root = newNode
    return newNode

  # Prevent duplication
  if root.object_ref.id == newNode.object_ref.id:
    return root  
    
  # Current dimension of comparison
  currDim = depth % kdTree.treeDim

  if (newNode.nodeVal[currDim] < root.nodeVal[currDim]):
    root.left = insertNodeInTree(root.left, newNode, depth + 1)
  else:
    root.right = insertNodeInTree(root.right, newNode, depth + 1)

  return root

def findMaxDInTree(root, d, depth, k_cache=[]):
  if root is None:
    return None

  currDim = depth % kdTree.treeDim

  if currDim == d and root not in k_cache:
    if root.right is None:
      return root
    else:
      tempNodeR = findMaxDInTree(root.right, d, depth + 1, k_cache)
      if tempNodeR is None or tempNodeR in k_cache:
        return root
      else:
        if root in k_cache:
          return tempNodeR
        else:
          return max_tN(d, root, tempNodeR)
  else:
    tempNodeL = findMaxDInTree(root.left, d, depth + 1, k_cache)
    tempNodeR = findMaxDInTree(root.right, d, depth + 1, k_cache)
    if (tempNodeL is None or tempNodeL in k_cache) and (tempNodeR is None or tempNodeR in k_cache):
      return root
    elif tempNodeL is None or tempNodeL in k_cache:
      if root in k_cache:
        return tempNodeR
      else:
        return max_tN(d, root, tempNodeR)
    elif tempNodeR is None or tempNodeR in k_cache:
      if root in k_cache:
        return tempNodeL
      else:
        return max_tN(d, root, tempNodeL)
    else:
      if root in k_cache:
        return max_tN(d, tempNodeL, tempNodeR)
      else:
        return max_tN(d, root, tempNodeL, tempNodeR)

def findMinDInTree(root, d, depth, k_cache=[]):
  if root is None:
    return None

  currDim = depth % kdTree.treeDim

  if currDim == d and root not in k_cache:
    if root.left is None:
      return root
    else:
      tempNodeL = findMinDInTree(root.left, d, depth + 1, k_cache)
      if tempNodeL is None or tempNodeL in k_cache:
        return root
      else:
        if root in k_cache:
          return tempNodeL
        else:
          return min_tN(d, root, tempNodeL)
  else:
    tempNodeL = findMinDInTree(root.left, d, depth + 1, k_cache)
    tempNodeR = findMinDInTree(root.right, d, depth + 1, k_cache)
    if (tempNodeL is None or tempNodeL in k_cache) and (tempNodeR is None or tempNodeR in k_cache):
      return root
    elif tempNodeL is None or tempNodeL in k_cache:
      if root in k_cache:
        return tempNodeR
      else:
        return min_tN(d, root, tempNodeR)
    elif tempNodeR is None or tempNodeR in k_cache:
      if root in k_cache:
        return tempNodeL
      else:
        return min_tN(d, root, tempNodeL)
    else:
      if root in k_cache:
        return min_tN(d, tempNodeL, tempNodeR)
      else:
        return min_tN(d, root, tempNodeL, tempNodeR)

def min_tN(comp_dim, treeNode1, treeNode2, treeNode3=None):
  min_node = treeNode1 if treeNode1.nodeVal[comp_dim] < treeNode2.nodeVal[comp_dim] else treeNode2
  if treeNode3 is None:
    return min_node
  else:
    min_node = treeNode3 if treeNode3.nodeVal[comp_dim] < min_node.nodeVal[comp_dim] else min_node
    return min_node 

def max_tN(comp_dim, treeNode1, treeNode2, treeNode3=None):
  max_node = treeNode1 if treeNode1.nodeVal[comp_dim] > treeNode2.nodeVal[comp_dim] else treeNode2
  if treeNode3 is None:
    return max_node
  else:
    max_node = treeNode3 if treeNode3.nodeVal[comp_dim] > max_node.nodeVal[comp_dim] else max_node
    return max_node 

class kdTree:
  treeDim = 4
  k_cache = []
  def __init__(self):
    self.root = None

  # wrapper to the insert node in tree function
  def insertNode(self, newNode):
    self.root = insertNodeInTree(self.root, newNode, 0)

  # wrapper to find maximum value in given dimension(s)
  def findMaxD(self, d):
    return findMaxDInTree(self.root, d, 0)

  def findTopKMaxD(self, d, k):
    kdTree.k_cache = []
    for _ in range(k):
      MN = findMaxDInTree(self.root, d, 0, kdTree.k_cache)
      kdTree.k_cache.append(MN)
    return kdTree.k_cache

  def findTopKMinD(self, d, k):
    kdTree.k_cache = []
    for _ in range(k):
      MN = findMinDInTree(self.root, d, 0, kdTree.k_cache)
      kdTree.k_cache.append(MN)
    return kdTree.k_cache

  # wrapper to find minimum value in a given dimension(s)
  def findMinD(self, d):
    return findMinDInTree(self.root, d, 0)

  def deleteNode(self, nodeId):
    pass
